package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"os"
	"runtime/debug"
	"sort"
	"strings"
	"sync"
	"time"

	"go.seankhliao.com/mono/ycli"
)

func main() {
	var a app
	ycli.OSExec(ycli.New(
		"mirrorrank",
		"test arch linux mirrors for download speed",
		a.register,
		a.run,
	))
}

type Mirror struct {
	u   string
	d   time.Duration
	err error
}

type app struct {
	ip4, ip6        bool
	countries       []string
	file, save      string
	parallel, limit int
	timeout         time.Duration
	exclude         map[string]struct{}
}

func (a *app) register(fs *flag.FlagSet) {
	a.exclude = map[string]struct{}{
		"checkdomain.de": {},
	}
	fs.BoolVar(&a.ip4, "4", false, "limit to IPv4")
	fs.BoolVar(&a.ip6, "6", false, "limit to IPv6")
	fs.StringVar(&a.file, "f", "", "mirrorlist to use instead of from archlinux.org/mirrorlist/")
	fs.StringVar(&a.save, "s", "/etc/pacman.d/mirrorlist", "output file location")
	fs.IntVar(&a.parallel, "p", 10, "parallel downloads")
	fs.IntVar(&a.limit, "l", 5, "limit output")
	fs.DurationVar(&a.timeout, "t", 5*time.Second, "timeout")
	fs.Func("e", "exclude string (repeatable)", func(s string) error {
		a.exclude[s] = struct{}{}
		return nil
	})
	fs.Func("c", "limit to countries (repeatable)", func(s string) error {
		a.countries = append(a.countries, s)
		return nil
	})
}

func (a *app) run(stdout, stderr io.Writer) error {
	lg := slog.New(slog.NewTextHandler(stderr, nil))

	client := http.Client{
		Timeout: 5 * time.Second,
	}

	// Get raw mirror list
	var rawMirrorlist io.Reader
	if a.file == "" {
		v := url.Values{}
		v.Add("protocol", "https")
		v.Add("use_mirror_status", "on")
		if a.ip4 {
			v.Add("ip_version", "4")
		}
		if a.ip6 {
			v.Add("ip_version", "6")
		}
		for _, c := range a.countries {
			v.Add("country", strings.ToUpper(c))
		}
		u := url.URL{
			Scheme:   "https",
			Host:     "archlinux.org",
			Path:     "/mirrorlist/",
			RawQuery: v.Encode(),
		}

		r, err := client.Get(u.String())
		if err != nil {
			return fmt.Errorf("get mirrorlist from remote: %w", err)
		}
		defer r.Body.Close()
		rawMirrorlist = r.Body
	} else {
		var err error
		rawMirrorlist, err = os.Open(a.file)
		if err != nil {
			return fmt.Errorf("read local mirrorlist: %w", err)
		}
	}

	// Parse raw mirror list
	var rawMirrors []string
	scanner := bufio.NewScanner(rawMirrorlist)
loop:
	for scanner.Scan() {
		s := strings.TrimPrefix(scanner.Text(), "#")
		s = strings.TrimSpace(s)
		var mirror string
		_, err := fmt.Sscanf(s, "Server = %s", &mirror)
		if err != nil {
			continue
		}
		for s := range a.exclude {
			if strings.Contains(mirror, s) {
				continue loop
			}
		}
		rawMirrors = append(rawMirrors, mirror)
	}

	lg.Info("got candidates", "mirrors", len(rawMirrors))

	// rank mirrors
	collect := make(chan Mirror)
	done := make(chan []Mirror)
	go func() {
		mirrors := make([]Mirror, 0, len(rawMirrors))
		var i int
		for m := range collect {
			i++
			if m.err != nil {
				lg.Warn("failed", "index", i, "total", len(rawMirrors), "err", m.err.Error(), "mirror", m.u)
				continue
			}
			lg.Debug("success", "index", i, "total", len(rawMirrors), "time", m.d, "mirror", m.u)
			mirrors = append(mirrors, m)
		}
		sort.Slice(mirrors, func(i, j int) bool { return mirrors[i].d.Milliseconds() < mirrors[j].d.Milliseconds() })
		done <- mirrors
	}()
	ch := make(chan struct{}, a.parallel)
	var wg sync.WaitGroup
	replacer := strings.NewReplacer("$repo", "extra", "$arch", "x86_64")
	for i := range rawMirrors {
		ch <- struct{}{}
		wg.Add(1)
		go func(m string) {
			defer func() {
				<-ch
				wg.Done()
			}()
			mirror := Mirror{u: m}
			u := replacer.Replace(m + "/extra.db")
			t := time.Now()
			var r *http.Response
			r, mirror.err = client.Get(u)
			if mirror.err == nil {
				defer r.Body.Close()
				_, mirror.err = io.Copy(io.Discard, r.Body)
			}
			mirror.d = time.Since(t)
			collect <- mirror
		}(rawMirrors[i])
	}
	wg.Wait()
	close(collect)

	mirrors := <-done

	// output mirrors
	bi, _ := debug.ReadBuildInfo()
	var b bytes.Buffer
	b.WriteString(fmt.Sprintf("## Generated by %s @ %s on %v\n", bi.Main.Path, bi.Main.Version, time.Now()))
	b.WriteString(fmt.Sprintf("## %s\n\n", strings.Join(os.Args, " ")))
	for _, m := range mirrors[:a.limit] {
		b.WriteString(fmt.Sprintf("Server = %s\n", m.u))
	}
	err := os.WriteFile(a.save, b.Bytes(), 0o644)
	if err != nil {
		return fmt.Errorf("write result: %w", err)
	}
	fmt.Println(b.String())
	return nil
}
