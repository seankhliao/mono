# protoc-gen-custom

## write your own custom protobuf code generator

### protoc-gen-custom

I was thinking about a more declarative way to do flags in Go,
maybe something like `RegisterFlags(myStruct)` 
and it looks at struct tags for tall the things wee need,
like name overrides, help text, default values.
But I didn't like the way struct tags were unstructured strings,
and it didn't sound like we'd get 
[structured tags](https://go.dev/issue/23637) 
anytime soon.

So my mind wandered over to [protobuf](https://protobuf.dev/).
It has structured 
[extension options](https://protobuf.dev/programming-guides/proto2/#options):

```proto
message MyMsg {
  options (my.thing).foo = 1;
  options (my.thing).bar = "two";

  string field1 = 1 [
    (my.thing).foo = 3, 
    (my.thing).bar = "four"
  ];
}
```

#### _custom_ extensions 

Let's start with defining some custom extensions.
We're adding options for messages and fields in messages.
I think it's probably nicer to have a single extension 
with a message as a type, 
rather than multiple extensions as it makes for less checks in the generator code.

```proto
syntax = "proto3";

package com.example.me;
option go_package = "me.example.com/goflag";

import "google/protobuf/duration.proto";
import "google/protobuf/descriptor.proto";

message GroupConfig {
  string prefix = 1;
  FlagCase case = 2;
}

enum FlagCase {
  SNAKE = 0;
  KEBAB = 1;
  DOT = 2;
}

extend google.protobuf.MessageOptions {
  optional GroupConfig flags = 59401;
}

message FlagConfig {
  optional string name = 1;
  string help = 2;
}

extend google.protobuf.FieldOptions {
  optional FlagConfig flag = 59501;
}
```

#### _code_ generator 

Now to write the code generator.
`protoc` looks at the flags it gets, like `--foo_out`,
and looks for executables named `protoc-gen-foo` in `$PATH`.
The exectuables take protobuf messages over stdin describing the parsed proto files
and writes the result to stdout.

We don't need to care about all that,
the [protogen](https://pkg.go.dev/google.golang.org/protobuf/compiler/protogen)
package handles it for us.
We just need write a callback.

For the setup, we'll loop over the input files,
and only run our generator if we're told we need to generate code for it 
(tbh, not sure when we're passed input we don't need).

```go
package main

import (
        "fmt"
        "io"
        "strconv"
        "strings"

        "me.example.com/goflag"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
        opt := protogen.Options{}
        opt.Run(func(p *protogen.Plugin) error {
                for _, file := range p.Files {
                        if !file.Generate {
                                continue
                        }

                        err := generateFile(p, file)
                        if err != nil {
                                return fmt.Errorf("%s: %w", file.Desc.Path(), err)
                        }
                }
                return nil
        })
}
```

For the actual generation,
we're given the filename prefix with which to attach a custom suffix.
The go import path is automagically calculated for us.
The final output is also formatted for us.

Go has a [convention](https://pkg.go.dev/cmd/go#hdr-Generate_Go_files_by_processing_source) 
of using the comment `^// Code generated .* DO NOT EDIT\.$`
to mark files as generated which should be ignored by tooling.

Looking over the messages is easy,
finding how to get the options out them less so.
I eventually figured (from peaking at vtprotobuf code)
it was `proto.GetExtension(msg.Desc.Options(), our_generated_proto.E_extension_name)`.
With that, the rest of generation was fairly easy.

```go
func generateFile(p *protogen.Plugin, file *protogen.File) error {
        fn := file.GeneratedFilenamePrefix + ".flag.go"

        f := p.NewGeneratedFile(fn, file.GoImportPath)

        io.WriteString(f, "// Code generated by protoc-gen-go-flag. DO NOT EDIT.\n\n")
        io.WriteString(f, "package "+string(file.GoPackageName)+"\n")
        io.WriteString(f, `import "flag"`)
        io.WriteString(f, "\n")

        var didGen bool
        for _, msg := range file.Messages {
                if !proto.HasExtension(msg.Desc.Options(), goflag.E_Flags) {
                        continue
                }
                didGen = true

                groupConf := proto.GetExtension(msg.Desc.Options(), goflag.E_Flags).(*goflag.GroupConfig)

                fmt.Fprintf(f, "func (x *%s) RegisterFlags(fset *flag.FlagSet) {\n", msg.GoIdent.GoName)
                for _, field := range msg.Fields {
                        var fieldConf *goflag.FlagConfig
                        if proto.HasExtension(field.Desc.Options(), goflag.E_Flag) {
                                fieldConf = proto.GetExtension(field.Desc.Options(), goflag.E_Flag).(*goflag.FlagConfig)
                        }

                        flagName := field.Desc.TextName()
                        if n := fieldConf.GetName(); n != "" {
                                flagName = n
                        }
                        if groupConf.Prefix != "" {
                                flagName = groupConf.Prefix + "_" + flagName
                        }
                        switch groupConf.Case {
                        case goflag.FlagCase_SNAKE:
                        // noop
                        case goflag.FlagCase_KEBAB:
                                flagName = strings.ReplaceAll(flagName, "_", "-")
                        case goflag.FlagCase_DOT:
                                flagName = strings.ReplaceAll(flagName, "_", ".")
                        }
                        flagName = strconv.Quote(flagName)

                        help := strconv.Quote(fieldConf.GetHelp())

                        var varType, defaultValue string
                        switch field.Desc.Kind() {
                        case protoreflect.BoolKind:
                                defaultValue = strconv.FormatBool(fieldConf.GetValBool())
                                varType = "Bool"
                        case protoreflect.Fixed32Kind,
                                protoreflect.Fixed64Kind,
                                protoreflect.Int32Kind,
                                protoreflect.Int64Kind,
                                protoreflect.Sfixed32Kind,
                                protoreflect.Sfixed64Kind,
                                protoreflect.Sint32Kind,
                                protoreflect.Sint64Kind:
                                defaultValue = strconv.FormatInt(fieldConf.GetValInt64(), 10)
                                varType = "Int64"
                                // case protoreflect.Uint32Kind, case protoreflect.Uint64Kind   :
                                // val = fieldConf.
                        case protoreflect.FloatKind, protoreflect.DoubleKind:
                                defaultValue = strconv.FormatFloat(fieldConf.GetValFloat(), 'f', 64, 64)
                                varType = "Float64"
                        case protoreflect.StringKind:
                                defaultValue = strconv.Quote(fieldConf.GetValString())
                                varType = "String"
                        case protoreflect.MessageKind:
                                switch field.Desc.FullName() {
                                case "google.protobuf.Duration":
                                        dur := fieldConf.GetValDur().AsDuration().Nanoseconds()
                                        defaultValue = strconv.FormatInt(dur, 10)
                                        varType = "Duration"
                                default:
                                        continue
                                }
                        case protoreflect.EnumKind,
                                protoreflect.GroupKind,
                                protoreflect.BytesKind:
                                continue
                        }

                        fmt.Fprintf(f, "fset.%sVar(&x.%s, %s, %s, %s)\n", varType, field.GoName, flagName, defaultValue, help)
                }
                fmt.Fprintf(f, "}\n")

        }

        if !didGen {
                f.Skip()
        }

        return nil
}
```

#### _testing_

It took a little bit of trial and error to figure out,
but the fully qualified import path need to be wrapped in `()`, 
while the message fields are outside.
The message can be passed either as individual fields,
or as a single message in prototext representation.
Annoyingly, we can't seem to refer to enum values(?).

```proto
syntax = "proto3";

package com.example.me.test;
option go_package = "me.example.com/test";

import "goflag/goflag.proto";

message Config {
  option (com.example.me.flags) = { prefix: "myapp" case: 1 };
  string http_host =1 [
    (com.example.me.flag).help = "the http host",
    (com.example.me.flag).val_string = "def"
  ];
  string foo = 2 [
    (com.example.me.flag) = { 
      name: "bar"
      help: "some renamed flag"
    }
  ];
}
```
