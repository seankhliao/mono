// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/envoyproxy/gateway/api/v1alpha1

package v1alpha1

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

// KindBackend is the name of the Backend kind.
#KindBackend: "Backend"

// AppProtocolType defines various backend applications protocols supported by Envoy Gateway
//
// +kubebuilder:validation:Enum=gateway.envoyproxy.io/h2c;gateway.envoyproxy.io/ws;gateway.envoyproxy.io/wss
#AppProtocolType: string // #enumAppProtocolType

#enumAppProtocolType:
	#AppProtocolTypeH2C |
	#AppProtocolTypeWS |
	#AppProtocolTypeWSS

// AppProtocolTypeH2C defines the HTTP/2 application protocol.
#AppProtocolTypeH2C: #AppProtocolType & "gateway.envoyproxy.io/h2c"

// AppProtocolTypeWS defines the WebSocket over HTTP protocol.
#AppProtocolTypeWS: #AppProtocolType & "gateway.envoyproxy.io/ws"

// AppProtocolTypeWSS defines the WebSocket over HTTPS protocol.
#AppProtocolTypeWSS: #AppProtocolType & "gateway.envoyproxy.io/wss"

// Backend allows the user to configure the endpoints of a backend and
// the behavior of the connection from Envoy Proxy to the backend.
//
// +kubebuilder:object:root=true
// +kubebuilder:resource:categories=envoy-gateway,shortName=be
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Status",type=string,JSONPath=`.status.conditions[?(@.type=="Accepted")].reason`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
#Backend: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Spec defines the desired state of Backend.
	spec: #BackendSpec @go(Spec)

	// Status defines the current status of Backend.
	status?: #BackendStatus @go(Status)
}

// BackendEndpoint describes a backend endpoint, which can be either a fully-qualified domain name, IP address or unix domain socket
// corresponding to Envoy's Address: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
//
// +kubebuilder:validation:XValidation:rule="(has(self.fqdn) || has(self.ip) || has(self.unix))",message="one of fqdn, ip or unix must be specified"
// +kubebuilder:validation:XValidation:rule="((has(self.fqdn) && !(has(self.ip) || has(self.unix))) || (has(self.ip) && !(has(self.fqdn) || has(self.unix))) || (has(self.unix) && !(has(self.ip) || has(self.fqdn))))",message="only one of fqdn, ip or unix can be specified"
#BackendEndpoint: {
	// FQDN defines a FQDN endpoint
	//
	// +optional
	fqdn?: null | #FQDNEndpoint @go(FQDN,*FQDNEndpoint)

	// IP defines an IP endpoint. Supports both IPv4 and IPv6 addresses.
	//
	// +optional
	ip?: null | #IPEndpoint @go(IP,*IPEndpoint)

	// Unix defines the unix domain socket endpoint
	//
	// +optional
	unix?: null | #UnixSocket @go(Unix,*UnixSocket)
}

// IPEndpoint describes TCP/UDP socket address, corresponding to Envoy's Socket Address
// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-socketaddress
#IPEndpoint: {
	// Address defines the IP address of the backend endpoint.
	// Supports both IPv4 and IPv6 addresses.
	//
	// +kubebuilder:validation:MinLength=3
	// +kubebuilder:validation:MaxLength=45
	// +kubebuilder:validation:Pattern=`^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$|^(([0-9a-fA-F]{1,4}:){1,7}[0-9a-fA-F]{1,4}|::|(([0-9a-fA-F]{1,4}:){0,5})?(:[0-9a-fA-F]{1,4}){1,2})$`
	address: string @go(Address)

	// Port defines the port of the backend endpoint.
	//
	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=65535
	port: int32 @go(Port)
}

// FQDNEndpoint describes TCP/UDP socket address, corresponding to Envoy's Socket Address
// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-socketaddress
#FQDNEndpoint: {
	// Hostname defines the FQDN hostname of the backend endpoint.
	//
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=253
	// +kubebuilder:validation:Pattern=`^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9]))*$`
	hostname: string @go(Hostname)

	// Port defines the port of the backend endpoint.
	//
	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=65535
	port: int32 @go(Port)
}

// UnixSocket describes TCP/UDP unix domain socket address, corresponding to Envoy's Pipe
// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-pipe
#UnixSocket: {
	// Path defines the unix domain socket path of the backend endpoint.
	path: string @go(Path)
}

// BackendSpec describes the desired state of BackendSpec.
#BackendSpec: {
	// Endpoints defines the endpoints to be used when connecting to the backend.
	//
	// +kubebuilder:validation:MinItems=1
	// +kubebuilder:validation:MaxItems=4
	// +kubebuilder:validation:XValidation:rule="self.all(f, has(f.fqdn)) || !self.exists(f, has(f.fqdn))",message="fqdn addresses cannot be mixed with other address types"
	endpoints?: [...#BackendEndpoint] @go(Endpoints,[]BackendEndpoint)

	// AppProtocols defines the application protocols to be supported when connecting to the backend.
	//
	// +optional
	appProtocols?: [...#AppProtocolType] @go(AppProtocols,[]AppProtocolType)

	// Fallback indicates whether the backend is designated as a fallback.
	// It is highly recommended to configure active or passive health checks to ensure that failover can be detected
	// when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
	// The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
	// the health of the active backends falls below 72%.
	//
	// +optional
	fallback?: null | bool @go(Fallback,*bool)
}

// BackendConditionType is a type of condition for a backend. This type should be
// used with a Backend resource Status.Conditions field.
#BackendConditionType: string // #enumBackendConditionType

#enumBackendConditionType:
	#BackendConditionAccepted

// BackendConditionReason is a reason for a backend condition.
#BackendConditionReason: string // #enumBackendConditionReason

#enumBackendConditionReason:
	#BackendReasonAccepted |
	#BackendReasonInvalid

// BackendConditionAccepted indicates whether the backend has been accepted or
// rejected by a targeted resource, and why.
//
// Possible reasons for this condition to be True are:
//
// * "Accepted"
//
// Possible reasons for this condition to be False are:
//
// * "Invalid"
//
#BackendConditionAccepted: #BackendConditionType & "Accepted"

// BackendReasonAccepted is used with the "Accepted" condition when the backend
// has been accepted by the targeted resource.
#BackendReasonAccepted: #BackendConditionReason & "Accepted"

// BackendReasonInvalid is used with the "Accepted" condition when the backend
// is syntactically or semantically invalid.
#BackendReasonInvalid: #BackendConditionReason & "Invalid"

// BackendStatus defines the state of Backend
#BackendStatus: {
	// Conditions describe the current conditions of the Backend.
	//
	// +optional
	// +listType=map
	// +listMapKey=type
	// +kubebuilder:validation:MaxItems=8
	conditions?: [...metav1.#Condition] @go(Conditions,[]metav1.Condition)
}

// BackendList contains a list of Backend resources.
//
// +kubebuilder:object:root=true
#BackendList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Backend] @go(Items,[]Backend)
}
